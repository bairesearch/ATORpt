"""ATORpt_PTrenderer.py

# Author:
Richard Bruce Baxter - Copyright (c) 2021-2024 Baxter AI (baxterai.com)

# License:
MIT License

# Installation:
See ATORpt_main.py

# Usage:
See ATORpt_main.py

# Description:
ATORpt PT renderer

"""

import torch as pt
import math

from ATORpt_globalDefs import *
import ATORpt_operations

import torch as pt
import torch.nn.functional as F

import matplotlib.pyplot as plt
if(snapshotRenderer == "pytorch3D"):
	from pytorch3d.structures import Meshes
	from pytorch3d.renderer import OpenGLPerspectiveCameras, MeshRenderer, MeshRasterizer, TexturesVertex, RasterizationSettings, SoftPhongShader, Textures
	#from pytorch3d.renderer.mesh.shader import LambertShader
	from pytorch3d.renderer.cameras import look_at_view_transform, FoVPerspectiveCameras, OrthographicCameras, FoVOrthographicCameras
	from pytorch3d.transforms.rotation_conversions import euler_angles_to_matrix

def resamplePixelCoordinates(transformedSnapshotPixelCoordinates, snapshotMeshValues, snapshotMeshFaces, renderViewportSize, renderImageSize, centreSnapshots=False, index=None):
	if(snapshotRenderer == "pytorch3D"):
		transformedPatches = renderSnapshotsPytorch3D(transformedSnapshotPixelCoordinates, snapshotMeshFaces, snapshotMeshValues, renderViewportSize, renderImageSize, centreSnapshots, index)
	return transformedPatches
	
def renderSnapshotsPytorch3D(verts, faces, colors, renderViewportSize, renderImageSize, centreSnapshots=False, index=None):		
	#TODO: check faces/colors generated by ATORpt_PTpolyKeypointGenerator (quad splitting into tris results in one tri being darker in each pair)
	
	#add Z dimension to coordinates
	vertsZ = pt.ones((verts.shape[0], verts.shape[1], 1)).to(device)
	vertsZ = vertsZ*snapshotRenderZdimVal
	verts = pt.cat((verts, vertsZ), dim=2)
	
	#print("verts.shape = ", verts.shape)
	#print("faces.shape = ", faces.shape)
	#print("colors.shape = ", colors.shape)
	#print("verts.dtype = ", verts.dtype)

	textures = TexturesVertex(verts_features=colors.to(device))	#or Textures(verts_rgb=colors.to(device)) 
	meshes = Meshes(verts=verts, faces=faces, textures=textures)
	
	T = pt.tensor([[0., 0., 0.]])
	angle_z = pt.deg2rad(pt.tensor(snapshotRenderCameraRotationZaxis))
	angle_y = pt.deg2rad(pt.tensor(snapshotRenderCameraRotationYaxis))
	angle_x = pt.deg2rad(pt.tensor(snapshotRenderCameraRotationXaxis))
	R = euler_angles_to_matrix(pt.tensor([angle_z, angle_y, angle_x]), "ZYX")
	R = R.unsqueeze(dim=0)
	
	min_x=-renderViewportSize[xAxisGeometricHashing]//2
	max_x=renderViewportSize[xAxisGeometricHashing]//2
	if(centreSnapshots):
		min_y=-renderViewportSize[yAxisGeometricHashing]//2
		max_y=renderViewportSize[yAxisGeometricHashing]//2
		#or T = pt.tensor([[0., 0., 0.]])
	else:
		#according to ATOR 2D0D specification, object triangles (ie normalised snapshots) are centred wrt the y axis, and placed on (ie above) the x axis
		min_y=0
		max_y=renderViewportSize[yAxisGeometricHashing]
		#or T = pt.tensor([[0., -renderViewportSize[yAxisGeometricHashing]//2., 0.]])
				
	cameras = FoVOrthographicCameras(min_x=min_x, min_y=min_y, max_x=max_x, max_y=max_y, znear=snapshotRenderCameraZnear, zfar=snapshotRenderCameraZfar, R=R, T=T, device=device)

	raster_settings = RasterizationSettings(image_size=renderImageSize, blur_radius=0.0, faces_per_pixel=1)
	shader = SoftPhongShader(device=device, cameras=cameras, lights=None)
	rasterizer = MeshRasterizer(cameras=cameras, raster_settings=raster_settings)
	renderer = MeshRenderer(rasterizer=rasterizer, shader=shader)
	images = renderer(meshes)	#format: N, H, W, C	#CUDA will throw out of memory if too many polys (see ATORmaxNumberATORpatchesAllImages)
	
	#print("verts[0] = ", verts[0])
	#print("faces[0] = ", faces[0])
	#print("colors[0] = ", colors[0])
	#print("images[0] = ", images[0])
	
	images = images[..., :3]	#remove the alpha channel
	
	if(debugSnapshotRender):
		if(index is not None):
			printImage(images[index])
		else:
			printImages(images)
	
	return images

def printImages(images):
	for image in images:
		printImage(image)

def printImage(image):
	#print("image = ", image)
	plt.figure(figsize=(8, 8))
	plt.imshow(image.squeeze().cpu().numpy())
	plt.axis('off')
	plt.show()
		
